(defparameter *transcription* (make-hash-table :test #'equal))

(defmacro populate-transcription-table (&rest alternating-keys-values)
  `(progn
     ,@(loop for index-value
	  from 1 below (length alternating-keys-values)
	  by 2
	  collect `(setf (gethash ,(elt alternating-keys-values (- index-value 1)) *transcription*)
			 ;;;; Future addition: handle lists of keys for duplicate values
			 ,(elt alternating-keys-values index-value)))))

(populate-transcription-table
 #\j #.(code-char 1488)
 #\b #.(code-char 1489)
 #\g #.(code-char 1490)
 #\d #.(code-char 1491)
 #\h #.(code-char 1492)
 #\v #.(code-char 1493)
 #\z #.(code-char 1494)
 #\H #.(code-char 1495)
 #\c #.(code-char 1496)
 #\y #.(code-char 1497)
 #\k #.(code-char 1499)
 #\l #.(code-char 1500)
 #\m #.(code-char 1502)
 #\n #.(code-char 1504)
 #\s #.(code-char 1505)
 #\J #.(code-char 1506)
 #\f #.(code-char 1508)
 #\x #.(code-char 1510)
 #\q #.(code-char 1511)
 #\r #.(code-char 1512)
 #\w #.(code-char 64298)
 #\R #.(code-char 64299)
 #\t #.(code-char 1514)

 #\B #.(code-char 64305)
 #\G #.(code-char 64306)
 #\D #.(code-char 64307)
 ";h" #.(code-char 64308)
 #\V #.(code-char 64309)
 "vO" #.(code-char 64331)
 #\Z #.(code-char 64310)
 #\C #.(code-char 64312)
 #\Y #.(code-char 64313)
 #\K #.(code-char 64315)
 "k " #.(code-char 1498)
 "K " #.(code-char 64314)
 #\L #.(code-char 64316)
 #\M #.(code-char 64318)
 "m " #.(code-char 1501)
 #\N #.(code-char 64320)
 "n " #.(code-char 1503)
 #\S #.(code-char 64321)
 #\F #.(code-char 64324)
 #\p #.(code-char 64324)
 "f " #.(code-char 1507)
 "p " #.(code-char 64323)
 "F " #.(code-char 64323)
 #\X #.(code-char 64326)
 "x " #.(code-char 1509)
 #\Q #.(code-char 64327)
 #\W #.(code-char 64300)
 ";R" #.(code-char 64301)
 #\T #.(code-char 64330)

 #\; #.(code-char 1456)
 ";e" #.(code-char 1457)
 ";a" #.(code-char 1458)
 ";o" #.(code-char 1459)
 #\i #.(code-char 1460)
 #\E #.(code-char 1461)
 #\e #.(code-char 1462)
 #\a #.(code-char 1463)
 #\A #.(code-char 1464)
 #\O #.(code-char 1465)
 #\u #.(code-char 1467)
 #\I #.(format nil "~a~a" (code-char 1460) (code-char 1497))

 ":d" #.(code-char 1468)
 ":m" #.(code-char 1468)
 ": " "")

(defun +nil (&rest cardinals)
  (loop for num in cardinals
     if (eq nil num) return nil
     summing num))

(defun transcription-reigon-handling (in-str)
  (with-output-to-string (out-str)
    (let ((chars-processed 0))
      (loop while chars-processed
	 do (let* ((start-reigon (search "::" in-str :start2 chars-processed))
		   (end-reigon (if start-reigon (search "::" in-str :start2 (1+ start-reigon)) nil)))
	      (princ (subseq in-str chars-processed start-reigon) out-str)
	      (if start-reigon (princ (transcribe-string (subseq in-str (+ 2 start-reigon) end-reigon)) out-str))
	      (setf chars-processed (+nil 2 end-reigon)))))))

(defun transcribe-string (english-str)
  (with-output-to-string (hebrew-str)
    (let (buf (read-position 0) (end-position (length english-str)))
      (loop while (< read-position end-position)
	   do (if (setf buf (gethash
			     (subseq english-str read-position
				     (if (> (+ 2 read-position) end-position)
					 nil
					 (+ 2 read-position)))
			     *transcription*))
		  (progn (princ buf hebrew-str)
			 (setf read-position (+ 2 read-position)))
		  (progn (princ
			  (or (gethash (char english-str read-position) *transcription*)
			      (char english-str read-position))
			  hebrew-str)
			 (setf read-position (1+ read-position))))))))